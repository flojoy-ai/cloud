"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.recurseExtract = exports.findSensitiveValues = exports.scrub = void 0;
const convenience_1 = require("./convenience");
const utils_1 = require("./utils");
// generic so it returns what yout put into it
// may not work though - we maybe transform some properties, so you don't really get out what you put in
/**
 * The easiest way to censor data - pass anything in along with a list of sensitive strings, and we'll handle the rest.
 */
const scrub = (input, secretValues) => {
    const sensitiveBank = (0, utils_1.makeSensitiveBank)(secretValues);
    // Sort by string length first and then by letters.
    // Otherwise, a sensitive bank {"abcdefg": "aa", "abcdefgh": "bb"} would censor {"api_key": "abcdefgh"}
    // into {"api_key": "aah"} while the desired output is {"api_key": "bb"}.
    const sortedKeys = Object.keys(sensitiveBank).sort((x, y) => x.length - y.length === 0 ? y.localeCompare(x) : y.length - x.length);
    const sensitiveBankEntries = sortedKeys
        .map((key) => [key, sensitiveBank[key]]);
    const replacer = (val) => {
        if (typeof val === 'string') {
            let copiedVal = val;
            // have to look for substrings in the value instead of looking for the value in the map
            sensitiveBankEntries.forEach(([transformed, censored]) => {
                copiedVal = (0, utils_1.replaceAll)(copiedVal, transformed, censored);
            });
            return copiedVal;
        }
        if (typeof val === 'number') {
            const numAsStr = val.toString();
            const maybeCensored = replacer(numAsStr);
            if (numAsStr === maybeCensored) {
                // not censored, return original numeric value
                return val;
            }
            return maybeCensored;
        }
        // return everything that's not a string or number unbothered
        return val;
    };
    return (0, utils_1.recurseReplace)(input, replacer);
};
exports.scrub = scrub;
/**
 * A convenience function to find potentially sensitive data in objects. It grabs:
 *
 * * any value tied to a typically sensitive key (such as `authorization` or `password`)
 * * any url (regardless of key) that has auth info or a querystring
 */
const findSensitiveValues = (obj) => {
    return (0, utils_1.recurseExtract)(obj, (key, value) => (0, convenience_1.isSensitiveKey)(key) || (0, convenience_1.isUrlWithSecrets)(value))
        .filter(utils_1.isLongEnoughToBeSecret)
        .reduce((result, value) => {
        // iterate the first pass and try to pull more specific info about of urls
        const urlSecrets = (0, convenience_1.extractSecretsFromUrl)(value);
        if (urlSecrets == null) {
            // value wasn't a url, pass it through
            return [...result, value];
        }
        // return any secrets found (could be 0), but not the full url
        return [...result, ...urlSecrets];
    }, []);
};
exports.findSensitiveValues = findSensitiveValues;
var utils_2 = require("./utils");
Object.defineProperty(exports, "recurseExtract", { enumerable: true, get: function () { return utils_2.recurseExtract; } });
