"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceAll = exports.recurseExtract = exports.recurseReplace = exports.makeSensitiveBank = exports.censor = exports.base64 = exports.hash = exports.isLongEnoughToBeSecret = void 0;
const create_hash_1 = __importDefault(require("create-hash"));
const isPlainObject = require("lodash.isplainobject");
const MIN_SECRET_SIZE = 6;
const isLongEnoughToBeSecret = (s) => s.length >= MIN_SECRET_SIZE;
exports.isLongEnoughToBeSecret = isLongEnoughToBeSecret;
const hash = (input) => (0, create_hash_1.default)('sha256').update(input, 'binary').digest('hex');
exports.hash = hash;
const base64 = (val) => {
    try {
        return Buffer.from(val).toString('base64');
    }
    catch (e) {
        // ignore; Buffer is semi-selective about what types it takes
    }
};
exports.base64 = base64;
// Clean up sensitive values in a hashed manner so they don't get logged.
const censor = (val) => {
    var _a;
    // if (!['string', 'number'].includes(typeof s)) {
    //   return null
    // }
    const salted = val + ((_a = process.env.ZAPIER_SCRUBBER_SALT) !== null && _a !== void 0 ? _a : 'averysecretsalt');
    const hashed = (0, exports.hash)(salted);
    return `:censored:${val.length}:${hashed.substring(0, 10)}:`;
};
exports.censor = censor;
/**
 * returns a mapping of sensitive string -> scrubbed string.
 * it considers transformations of the input, such as percent-encoding
 */
const makeSensitiveBank = (secretValues) => {
    if (secretValues.length === 0) {
        throw new Error('Need at least 1 secret value');
    }
    return secretValues.reduce((bank, val) => {
        if (typeof val === 'number') {
            val = val.toString();
        }
        // keeps short values from spamming censor strings in logs, < 6 chars is not a proper secret
        // see https://github.com/zapier/zapier-platform-core/issues/4#issuecomment-277855071
        if ((0, exports.isLongEnoughToBeSecret)(val)) {
            const censored = (0, exports.censor)(val);
            // exhaustive list of possible transforms
            // important that this list lines up with what we do in python!
            const transforms = new Set();
            // 1. as-is
            transforms.add(val);
            // 2. percent-encoded (python's urllib.parse.quote)
            transforms.add(encodeURIComponent(val));
            // 3. percent-encoded, but spaces are "+" (python's urllib.parse.quote_plus)
            transforms.add(encodeURIComponent(val).replace(/%20/g, '+'));
            // 4. JSONStringy-ied (to catch double backslashes)
            // slice to remove the leading and trailing `"`
            transforms.add(JSON.stringify(val).slice(1, -1));
            // 5. base 64 encoded
            const base64Secret = (0, exports.base64)(val);
            if (base64Secret !== undefined) {
                transforms.add(base64Secret);
            }
            transforms.forEach((v) => {
                bank[v] = censored;
            });
        }
        return bank;
    }, {});
};
exports.makeSensitiveBank = makeSensitiveBank;
/**
 * Takes anything as input and returns a **copy** where each item has been run through the `replacer`. Can handle deeply-nested objects.
 *
 * The `replacer` function should always return a value; a good default is returning its sole input.
 */
const recurseReplace = (obj, replacer) => {
    if (Array.isArray(obj)) {
        return obj.map((value) => {
            return (0, exports.recurseReplace)(value, replacer);
        });
    }
    else if (isPlainObject(obj)) {
        return Object.entries(obj).reduce((prev, [key, value]) => {
            prev[key] = (0, exports.recurseReplace)(value, replacer);
            return prev;
        }, {});
    }
    else {
        obj = replacer(obj);
    }
    return obj;
};
exports.recurseReplace = recurseReplace;
/**
 * Convenience function for finding potentially sensitive values in objects.
 *
 * It returns stringified versions of any values that were found in the below steps.
 *
 * In the root object, each key/value pair are passed to the `matcher` function. Then:
 * * if the value is an object, the function recurses
 * * if the value is an array, we iterate each element:
 *   * if the element is an object or array, we recurse
 *   * otherwise, we call the matcher with **only** the value (`matcher('', value)`)
 * * otherwise, we pass the key and value to the matcher. If it returns `true`, we collect the value
 */
const recurseExtract = (obj, matcher) => {
    const result = Object.entries(obj)
        .map(([key, value]) => {
        if (isPlainObject(value)) {
            return (0, exports.recurseExtract)(value, matcher);
        }
        if (Array.isArray(value)) {
            return value.map((val) => isPlainObject(val) || Array.isArray(val)
                ? (0, exports.recurseExtract)(val, matcher)
                : matcher('', val)
                    ? val
                    : null // find array elements too
            );
        }
        // value is simple-ish
        if (matcher(key, value)) {
            return value === null || value === void 0 ? void 0 : value.toString();
        }
    })
        .flat(5) // probably enough recursive layers?
        .filter(Boolean);
    return result;
};
exports.recurseExtract = recurseExtract;
/**
 * Custom implementation of String.prototype.replaceAll (not tied to the String namespace though).
 *
 * Key differences between String.prototype.replaceAll and this implementation:
 *   - searchString only supports Strings (not regex)
 *   - replaceValue only supports Strings (not functions)
 *   - replaceValue must not be the empty string
 *
 * Source for inspiration: https://github.com/zloirock/core-js/blob/master/packages/core-js/modules/es.string.replace-all.js
 */
const replaceAll = (baseString, searchString, replaceValue) => {
    if (searchString === '') {
        return baseString;
    }
    let result = '';
    let endOfLastMatch = 0;
    let position = baseString.indexOf(searchString);
    while (position !== -1) {
        result += baseString.slice(endOfLastMatch, position) + replaceValue;
        endOfLastMatch = position + searchString.length;
        position = baseString.indexOf(searchString, endOfLastMatch);
    }
    if (endOfLastMatch < baseString.length) {
        result += baseString.slice(endOfLastMatch);
    }
    return result;
};
exports.replaceAll = replaceAll;
